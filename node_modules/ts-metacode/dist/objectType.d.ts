import { MapUnit, MapElement, MapType } from ".";
export declare type MergeObject<A, B> = {
    [idx in (keyof A | keyof B)]: idx extends keyof A ? idx extends keyof B ? (MergeType<A[idx], B[idx]>) : (idx extends keyof A ? A[idx] : idx extends keyof B ? B[idx] : never) : (idx extends keyof A ? A[idx] : idx extends keyof B ? B[idx] : never);
};
declare type MergeRaw<A, B> = A | B;
declare type MergeArr<A, B> = A extends Array<infer AT> ? (B extends Array<infer BT> ? Array<AT | BT> : never) : never;
declare type MergeItr<A, B> = A extends Iterable<infer AT> ? (B extends Iterable<infer BT> ? Iterable<AT | BT> : never) : never;
declare type MergeAsyncItr<A, B> = A extends AsyncIterable<infer AT> ? (B extends AsyncIterable<infer BT> ? AsyncIterable<AT | BT> : never) : never;
export declare type MergeType<A, B> = MergeArr<A, B> extends never ? (MergeItr<A, B> extends never ? (MergeAsyncItr<A, B> extends never ? (A extends B ? A : B extends A ? B : A extends object ? B extends object ? MergeObject<A, B> : MergeRaw<A, B> : MergeRaw<A, B>) : MergeAsyncItr<A, B>) : MergeItr<A, B>) : MergeArr<A, B>;
export declare type MapProp<T extends any, M extends MapUnit<any, any>[]> = MapElement<T, M>;
export declare type MapRecursion<T extends any, M extends MapUnit<any, any>[], JudgeType = object> = {
    [R in keyof T]: T[R] extends JudgeType ? MapRecursion<T[R], M, JudgeType> : MapType<T[R], M>;
};
export {};
