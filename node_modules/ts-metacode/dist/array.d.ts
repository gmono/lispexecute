import { MapUnit, MapType } from ".";
import { Zero, SNum, sEqual, sDec, sInc, Dec, sAdd, sMoreThan, sSub } from './math';
export declare type MapElement<T extends any, M extends MapUnit<any, any>[]> = {
    [R in keyof T]: MapType<T[R], M>;
};
export declare type Zip<a, b> = a extends [infer i, ...infer q] ? b extends [infer ii, ...infer qq] ? [[i, ii], ...Zip<q, qq>] : [] : [];
export declare type Concat<One extends any[], Two extends any[]> = [...One, ...Two];
export declare type Head<Raw extends any[]> = Raw extends [infer S, ...infer Rest] ? S : never;
export declare type Tail<Raw extends any[]> = Raw extends [infer Set, ...infer Rest] ? Rest : never;
export declare type Shift<Raw extends any[], Ele> = [Ele, ...Raw];
export declare type UnShift<Raw extends any[]> = Head<Raw>;
export declare type Push<Raw extends any[], Ele> = [...Raw, Ele];
export declare type Previous<Raw extends [any, ...any[]]> = Raw extends [...infer P, infer Ele] ? P : never;
export declare type Pop<Raw extends [any, ...any[]]> = Last<Raw>;
export declare type Last<Raw extends [any, ...any[]]> = Raw extends [...infer P, infer Ele] ? Ele : never;
export declare type RemoveFront<R extends any[], K extends any[]> = R extends [] ? (K extends [] ? [] : never) : (R extends [...K, ...infer Rest] ? Rest : never);
export declare type RemoveEnd<R extends any[], K extends any[]> = R extends [] ? (K extends [] ? [] : never) : (R extends [...infer Rest, ...K] ? Rest : never);
export declare type RemoveSame<R extends any[], K extends any[]> = R extends [] ? (K extends [] ? [] : never) : (RemoveFront<R, K> extends never ? Shift<RemoveSame<Tail<R>, K>, Head<R>> : RemoveFront<R, K>);
export declare type RemoveAllSame<R extends any[], K extends any[]> = RemoveSame<R, K> extends never ? R : RemoveAllSame<RemoveSame<R, K>, K>;
export declare type ReplaceOne<R extends any[], A extends any[], B extends any[]> = R extends [] ? [] : (RemoveFront<R, A> extends never ? Shift<ReplaceOne<Tail<R>, A, B>, Head<R>> : [...B, ...RemoveFront<R, A>]);
export declare type ReplaceAll<R extends any[], A extends any[], B extends any[]> = R extends [] ? [] : (RemoveFront<R, A> extends never ? Shift<ReplaceAll<Tail<R>, A, B>, Head<R>> : [...B, ...ReplaceAll<RemoveFront<R, A>, A, B>]);
export declare type IndexOf<R extends any[], A extends any[], NowIndx extends SNum = Zero> = R extends [] ? never : RemoveFront<R, A> extends never ? (IndexOf<Tail<R>, A, sInc<NowIndx>>) : NowIndx;
export declare type ReverseToEnd<T extends any[]> = Push<Tail<T>, Head<T>>;
export declare type Get<T extends any[], idx extends SNum> = idx extends Zero ? T[0] : Get<Tail<T>, sDec<idx>>;
declare type _Slice<T extends any[], start extends SNum> = start extends Zero ? T : _Slice<Tail<T>, sDec<start>>;
export declare type Slice<T extends any[], start extends SNum = Zero, end extends SNum = Length<T>> = RemoveEnd<_Slice<T, start>, _Slice<T, end>>;
export declare type Insert<T extends any[], idx extends SNum, subAr extends any[]> = [
    ...RemoveEnd<T, _Slice<T, idx>>,
    ...subAr,
    ..._Slice<T, idx>
];
export declare type CutEnd<R extends any[], K extends any[]> = Slice<R, Dec<0>, sSub<Length<R>, Length<K>>>;
export declare type CutFront<R extends any[], K extends any[]> = Slice<R, Length<K>>;
export declare type MergeArrayEnd<R extends any[], K extends any[]> = Concat<CutEnd<R, K>, K>;
export declare type MergeArrayFront<R extends any[], K extends any[]> = Concat<K, CutFront<R, K>>;
export declare type RewriteEnd<R extends any[], K extends any[]> = MergeArrayEnd<R, K>;
export declare type RewriteFront<R extends any[], K extends any[]> = MergeArrayFront<R, K>;
export declare type Filter<ar extends any[], ju extends [any, boolean][]> = ar extends [infer t, ...infer ttt] ? (MapType<t, ju> extends true ? ([
    t,
    ...Filter<ttt, ju>
]) : (Filter<ttt, ju>)) : [];
export declare type DeleteSameElement<art extends any[]> = art extends [infer n, ...infer r] ? ([[n, false], ...DeleteSameElement<r>]) : [[any, true]];
export declare type Skip<art extends any[], num extends SNum> = sEqual<num, Zero> extends [true] ? art : Skip<Tail<art>, sDec<num>>;
export declare type Range<start extends SNum, space extends SNum, end extends SNum, Now extends SNum = start, nowar extends string[] = []> = sMoreThan<Now, end> extends [true] ? nowar : sEqual<Now, end> extends [true] ? nowar : Range<start, space, end, sAdd<Now, space>, [...nowar, Now]>;
export declare type Length<a extends any[]> = Dec<a["length"]>;
export {};
