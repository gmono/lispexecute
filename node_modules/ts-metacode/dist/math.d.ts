import { MapType } from '.';
import { MapElement, AND, NOT } from ".";
import { JOIN, CanBeString, Split } from './string';
import { MapUnit, MapTypeLong } from './common';
import { MergeArrayEnd } from './array';
import { OR } from './logic';
export declare type BinToLogic<s extends string> = s extends "" ? [] : s extends `0${infer tail}` ? [false, ...BinToLogic<tail>] : s extends `1${infer tail}` ? [true, ...BinToLogic<tail>] : never;
export declare type LogicToBin<s extends boolean[]> = JOIN<MapElement<s, [[true, "1"], [false, "0"]]>>;
export declare type SNum = string;
export declare type Zero = "";
export declare type One = "x";
export declare type Num<T extends SNum | number> = T extends number ? Dec<T> : T;
export declare type __ToNum<T extends SNum> = T;
export declare type sMoreOrEqual<P extends SNum, R extends SNum> = OR<sEqual<P, R>, sMoreThan<P, R>>;
export declare type sLessOrEqual<P extends SNum, R extends SNum> = OR<sEqual<P, R>, sLessThan<P, R>>;
export declare type sMoreThan<P extends SNum, R extends SNum> = __ToNum<P> extends `${__ToNum<R>}${infer ANY}x` ? [true] : [false];
export declare type sEqual<P extends SNum, R extends SNum> = __ToNum<P> extends __ToNum<R> ? [true] : [false];
export declare type sLessThan<P extends SNum, R extends SNum> = AND<NOT<sMoreThan<P, R>>, NOT<sEqual<P, R>>>;
export declare type sInc<R extends SNum> = `${__ToNum<R>}x`;
export declare type sDec<R extends SNum> = __ToNum<R> extends `${infer T}x` ? T : Zero;
export declare type sAdd<R extends SNum, P extends SNum> = `${__ToNum<R>}${__ToNum<P>}`;
export declare type sSub<R extends SNum, P extends SNum> = __ToNum<R> extends `${__ToNum<P>}${infer T}` ? T : never;
export declare type sMul<R extends SNum, P extends SNum> = __ToNum<P> extends Zero ? Zero : (`${__ToNum<R>}${sMul<R, sDec<P>>}`);
export declare type sDiv<R extends SNum, P extends SNum, NowTry extends SNum = One> = __ToNum<P> extends Zero ? never : sMoreThan<P, R> extends [true] ? Zero : (sMul<P, NowTry> extends __ToNum<R> ? NowTry : (sMoreThan<sMul<P, sInc<NowTry>>, R> extends [true] ? NowTry : sDiv<R, P, sInc<NowTry>>));
export declare type LogicToSNum<s extends boolean[]> = s extends [...infer rest, infer l] ? (rest extends [] ? (l extends true ? "x" : "") : (rest extends boolean[] ? sAdd<sMul<LogicToSNum<rest>, "xx">, (l extends true ? "x" : "")> : never)) : "";
export declare type BinToSNum<s extends string> = LogicToSNum<BinToLogic<s>>;
export declare type BaseMap<s extends CanBeString, mt extends MapUnit<any, any>[]> = _BaseMap<Split<s, "">, mt>;
export declare type _BaseMap<s extends CanBeString[], mt extends MapUnit<any, any>[]> = s extends [infer a, ...infer b] ? (MapType<a, mt> extends CanBeString ? b extends CanBeString[] ? `${MapType<a, mt>}${_BaseMap<b, mt>}` : never : never) : Zero;
export declare type Bin<s extends CanBeString> = BinToSNum<`${s}`>;
declare type _Dec<s extends string[]> = s extends [...infer b, infer a] ? (b extends [] ? (a extends string ? _MapDEC<a> : never) : (a extends string ? b extends string[] ? sAdd<_MapDEC<a>, sMul<_Dec<b>, Ten>> : never : never)) : Zero;
export declare type Dec<s extends CanBeString> = _Dec<Split<`${s}`, "">>;
declare type _OCT<s extends string[]> = s extends [...infer b, infer a] ? (b extends [] ? (a extends string ? _MapOCT<a> : never) : (a extends string ? b extends string[] ? sAdd<_MapOCT<a>, sMul<_OCT<b>, Eight>> : never : never)) : Zero;
export declare type OCT<s extends CanBeString> = _OCT<Split<`${s}`, "">>;
declare type _HEX<s extends string[]> = s extends [...infer b, infer a] ? (b extends [] ? (a extends string ? _MapHEX<a> : never) : (a extends string ? b extends string[] ? sAdd<_MapHEX<a>, sMul<_HEX<b>, Sixteen>> : never : never)) : Zero;
export declare type HEX<s extends CanBeString> = _HEX<Split<`${s}`, "">>;
declare type _MapDEC<s extends string> = MapTypeLong<s, [
    [
        "0",
        ""
    ],
    [
        "1",
        "x"
    ],
    [
        "2",
        "xx"
    ],
    [
        "3",
        "xxx"
    ],
    [
        "4",
        "xxxx"
    ],
    [
        "5",
        "xxxxx"
    ],
    [
        "6",
        "xxxxxx"
    ],
    [
        "7",
        "xxxxxxx"
    ],
    [
        "8",
        "xxxxxxxx"
    ],
    [
        "9",
        "xxxxxxxxx"
    ]
]>;
declare type _MapOCT<s extends string> = MapType<s, [
    [
        "0",
        ""
    ],
    [
        "1",
        "x"
    ],
    [
        "2",
        "xx"
    ],
    [
        "3",
        "xxx"
    ],
    [
        "4",
        "xxxx"
    ],
    [
        "5",
        "xxxxx"
    ],
    [
        "6",
        "xxxxxx"
    ],
    [
        "7",
        "xxxxxxx"
    ]
]>;
declare type _MapHEX<s extends string> = MapTypeLong<s, [
    [
        "0",
        ""
    ],
    [
        "1",
        "x"
    ],
    [
        "2",
        "xx"
    ],
    [
        "3",
        "xxx"
    ],
    [
        "4",
        "xxxx"
    ],
    [
        "5",
        "xxxxx"
    ],
    [
        "6",
        "xxxxxx"
    ],
    [
        "7",
        "xxxxxxx"
    ],
    [
        "8",
        "xxxxxxxx"
    ],
    [
        "9",
        "xxxxxxxxx"
    ],
    [
        "a",
        "xxxxxxxxxx"
    ],
    [
        "b",
        "xxxxxxxxxxx"
    ],
    [
        "c",
        "xxxxxxxxxxxx"
    ],
    [
        "d",
        "xxxxxxxxxxxxx"
    ],
    [
        "e",
        "xxxxxxxxxxxxxx"
    ],
    [
        "f",
        "xxxxxxxxxxxxxxx"
    ],
    [
        "A",
        "xxxxxxxxxx"
    ],
    [
        "B",
        "xxxxxxxxxxx"
    ],
    [
        "C",
        "xxxxxxxxxxxx"
    ],
    [
        "D",
        "xxxxxxxxxxxxx"
    ],
    [
        "E",
        "xxxxxxxxxxxxxx"
    ],
    [
        "F",
        "xxxxxxxxxxxxxxx"
    ]
]>;
export declare type Ten = sMul<"xxxxx", "xx">;
export declare type Eight = sMul<"xxxx", "xx">;
export declare type Sixteen = sMul<Eight, "xx">;
declare type _SNumToLogic<T extends SNum, Now extends boolean[] = [], NowSum extends SNum = Zero> = T extends Zero ? [false] : T extends One ? [true] : Now extends [true, ...infer S] ? (sMoreThan<sMul<NowSum, Dec<2>>, T> extends [true] ? Now : _SNumToLogic<T, [...Now, false], sMul<NowSum, Dec<2>>>) : _SNumToLogic<T, [true], Dec<1>>;
export declare type SNumToLogic<T extends SNum> = sSub<T, LogicToSNum<_SNumToLogic<T>>> extends Zero ? _SNumToLogic<T> : MergeArrayEnd<_SNumToLogic<T>, SNumToLogic<sSub<T, LogicToSNum<_SNumToLogic<T>>>>>;
export declare type SNumToBin<T extends SNum> = SNumToLogic<T> extends boolean[] ? LogicToBin<SNumToLogic<T>> : never;
export {};
