export declare function delay(mis: any): Promise<void>;
export declare function randint(max: number): number;
export declare function range(end: number): Iterable<number>;
export declare function range(start: number, end: number): Iterable<number>;
export declare function range(start: number, space: number, end: number): Iterable<number>;
export declare function enumerate<T>(arraylike: Iterable<T>): Iterable<[number, T]>;
export declare function any(arraylike: Iterable<any>): boolean;
export declare function all(arraylike: Iterable<any>): boolean;
export declare function not(arraylike: Iterable<boolean>): any[];
export declare type CompareAble<D> = {
    __equal__(b: D): boolean;
};
export declare type CompareDest<D> = D | Iterable<D>;
export declare function equal<D>(ar: Iterable<CompareAble<D>>, dest: CompareDest<D>): boolean[];
export declare function print<T extends any[]>(...data: T): void;
export declare type MapToIteratable<T extends any[]> = {
    [R in keyof T]: Iterable<T[R]>;
};
export declare type ZipType<T extends any[]> = Iterable<T>;
declare type IterInnerNorm<T> = T extends Iterable<infer S> ? S : T extends AsyncIterable<infer SS> ? Promise<SS> : never;
export declare function error(msg?: string): void;
export declare function zip<T extends [any, ...any[]]>(arraylikes: MapToIteratable<T>): Generator<T, void, void>;
export declare function zip<T extends Iterable<any>>(arraylikes: Iterable<T>): Generator<IterInnerNorm<T>[], void, void>;
export declare function zip<T extends any[]>(...arraylikes: MapToIteratable<T>): Generator<T, void, void>;
declare type MapToInner<ar> = ar extends [infer a, ...infer b] ? (a extends Iterable<infer n> ? [n, ...MapToInner<b>] : "never") : [];
export declare function cartesian<ar extends Iterable<any>[]>(...args: ar): Generator<MapToInner<ar>, void, unknown>;
export declare function shuffle<T>(arl: Iterable<T>): T[];
export declare function sorted<T>(arl: Iterable<T>, key?: (v: T) => number, sorttype?: "ASC" | "DESC"): T[];
export declare function byIdx<T>(arl: Iterable<T>, idxs: number[]): T[];
export declare function extract<T>(arl: Iterable<T>, count: number): T[];
export declare function sample<T>(arl: Iterable<T>, count: number): T[];
export declare let min: (...values: number[]) => number;
export declare let max: (...values: number[]) => number;
export declare function insert<T>(arl: Iterable<T>, point: number, val: T): T[];
export interface AsInt {
    toInt(): number;
}
export interface AsFloat {
    toFloat(): number;
}
export declare function int(other: string | number | AsInt): number;
export declare type AsString = {
    toString: () => string;
} | number | string;
export declare function str(n: AsString): string;
export declare function float(other: string | number | AsFloat): number;
export declare function json(obj: any): string;
export declare function parse(json: string): any;
export declare function assert(n: boolean, msg?: string): void;
export declare type TypeNameList = RawTypeNameList | "object" | "function";
export declare type RawTypeNameList = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined";
export declare type RawTypeList = string | number | bigint | boolean | symbol | undefined;
export declare type TypeList = RawTypeNameList | object | Function;
export declare type TypeMap<tp extends TypeList> = tp extends string ? "string" : tp extends number ? "number" : tp extends bigint ? "bigint" : tp extends boolean ? "boolean" : tp extends symbol ? "symbol" : tp extends Function ? "function" : tp extends undefined ? "undefined" : tp extends object ? "object" : never;
export declare type TypeNameMap<name extends TypeNameList> = name extends "string" ? string : name extends "number" ? number : name extends "bigint" ? bigint : name extends "boolean" ? boolean : name extends "symbol" ? symbol : name extends "function" ? Function : name extends "undefined" ? undefined : name extends "object" ? object : never;
export declare type ClassType = new (...args: any[]) => any;
export declare function assertType<T extends TypeNameList>(obj: any, typename: T): obj is TypeNameMap<T>;
export declare function assertType<T extends object, S extends ClassType>(obj: T, cls: S): obj is InstanceType<S>;
export declare function trustType<T>(o: any): o is T;
export declare function isIter<T extends any>(a: any): a is Iterable<T>;
export declare function isAsyncIter<T extends any>(a: any): a is AsyncIterable<T>;
export declare function list<T>(iter?: Iterable<T>): Array<T>;
export declare function dict<K, V>(arl: Iterable<[K, V]>): Map<K, V>;
export declare function zipToDict<K, V>(ks: Iterable<K>, vs: Iterable<V>): Map<K, V>;
export declare function set<T>(arl: Iterable<T>): Set<T>;
export declare function keys<T extends object = any, K = any, V = any>(obj: T | Map<K, V>): Generator<K | Extract<keyof T, string>, void, unknown>;
export declare type HasLength = {
    length: number;
} | {
    size: number;
} | {
    count: number;
} | {
    __len__(): number;
};
export declare function len(obj: Iterable<any> | HasLength | object): any;
export declare function mapToObj(map?: Map<any, any>): {};
export declare function call(func: () => any): void;
export declare type Error<msg extends string> = {
    error: msg;
};
import type { Tail, Head, Slice, Length, SNum, sEqual, One, Zero, sDec } from "ts-metacode";
declare type CurriedFunction<Func extends Function> = Func extends (...args: infer P) => infer R ? (sEqual<Length<P>, Zero> extends [true] ? Func : sEqual<Length<P>, One> extends [true] ? Func : (...args: Slice<P, Zero, One>) => CurriedFunction<(...args: Tail<P>) => R>) : never;
declare type ReduceFunction<cfunc, PP extends any[], n extends SNum = Length<PP>> = n extends Zero ? cfunc : (cfunc extends (...args: infer P) => infer R ? (Head<PP> extends Head<P> ? ReduceFunction<R, Tail<PP>, sDec<n>> : Error<`参数类型不一致`>) : Error<"参数过多或存在rest参数">);
declare type CurryReturn<Func> = Func extends (...args: infer P) => infer R ? (<PP extends any[]>(...vargs: PP) => (CurryReturn<ReduceFunction<Func, PP>>)) : Func;
export declare function curry<Func extends Function, Raw extends Function>(f: Func, now?: number, raw?: (Raw extends unknown ? Func : Raw)): CurryReturn<CurriedFunction<Func>>;
export declare function cached<T extends any[], R>(func: (...args: T) => R): (...args: T) => Readonly<R>;
export {};
